// IMPLEMENTATION_VALIDATION
import { existsSync } from "node:fs";
import type { PortAllocator, PortAllocation } from "./port-allocator";
import type { FeatureMetadata, LaceMountDeclaration } from "./feature-metadata";
import { extractLaceCustomizations, parseMountDeclarationEntry } from "./feature-metadata";
import type {
  AutoGeneratedPortEntries,
  FeaturePortDeclaration,
  PortAttributes,
} from "./port-allocator";
import type { MountPathResolver, MountAssignment } from "./mount-resolver";
import { expandPath } from "./settings";

// ── Types ──

/** Result of resolving all templates in a devcontainer.json. */
export interface TemplateResolutionResult {
  /** The config with all ${lace.port()} expressions replaced by concrete values. */
  resolvedConfig: Record<string, unknown>;
  /** All port allocations made during resolution (new and reused). */
  allocations: PortAllocation[];
  /** Warnings generated during resolution (e.g., metadata unavailable). */
  warnings: string[];
  /** All mount path assignments made during resolution. */
  mountAssignments: MountAssignment[];
}

/** Parsed result of extracting a featureId from a feature reference. */
export interface ParsedFeatureRef {
  /** The full feature reference (e.g., "ghcr.io/weftwiseink/devcontainer-features/wezterm-server:1"). */
  fullRef: string;
  /** The short ID extracted from the last path segment, version stripped (e.g., "wezterm-server"). */
  shortId: string;
}

// ── Patterns ──

const LACE_PORT_PATTERN = /\$\{lace\.port\(([^)]+)\)\}/g;
// v2 accessor-syntax patterns (match order: more specific first)
const LACE_MOUNT_TARGET_PATTERN = /\$\{lace\.mount\(([^)]+)\)\.target\}/g;
const LACE_MOUNT_SOURCE_PATTERN = /\$\{lace\.mount\(([^)]+)\)\.source\}/g;
const LACE_MOUNT_PATTERN = /\$\{lace\.mount\(([^)]+)\)\}/g;
// Guard: rejects any ${lace.*} that isn't port() or mount()
const LACE_UNKNOWN_PATTERN = /\$\{lace\.(?!port\(|mount\()([^}]+)\}/;
const LACE_PORT_FULL_MATCH = /^\$\{lace\.port\(([^)]+)\)\}$/;

// ── Prebuild features raw access ──

/**
 * Extract a direct reference to the prebuildFeatures object from a config.
 * Returns the live object for in-place mutation, or an empty object if absent/null/empty.
 * This is a lightweight accessor -- use extractPrebuildFeatures() from devcontainer.ts
 * for discriminated-union handling in the prebuild pipeline.
 */
export function extractPrebuildFeaturesRaw(
  config: Record<string, unknown>,
): Record<string, Record<string, unknown>> {
  const customizations = config.customizations as
    | Record<string, unknown>
    | undefined;
  if (!customizations) return {};

  const lace = customizations.lace as Record<string, unknown> | undefined;
  if (!lace) return {};

  if (!("prebuildFeatures" in lace)) return {};

  const prebuildFeatures = lace.prebuildFeatures;
  if (prebuildFeatures === null) return {};
  if (
    typeof prebuildFeatures !== "object" ||
    Object.keys(prebuildFeatures as object).length === 0
  ) {
    return {};
  }

  return prebuildFeatures as Record<string, Record<string, unknown>>;
}

// ── Project mount declarations ──

/**
 * Extract project-level mount declarations from devcontainer config.
 * Reads customizations.lace.mounts from the devcontainer config.
 * Returns declarations prefixed with "project/".
 */
export function extractProjectMountDeclarations(
  config: Record<string, unknown>,
): Record<string, LaceMountDeclaration> {
  const customizations = config.customizations as
    | Record<string, unknown>
    | undefined;
  if (!customizations) return {};

  const lace = customizations.lace as Record<string, unknown> | undefined;
  if (!lace) return {};

  const mounts = lace.mounts;
  if (!mounts || typeof mounts !== "object") return {};

  const result: Record<string, LaceMountDeclaration> = {};
  for (const [key, value] of Object.entries(mounts as Record<string, unknown>)) {
    const parsed = parseMountDeclarationEntry(key, value);
    if (parsed) {
      result[`project/${key}`] = parsed;
    }
  }
  return result;
}

// ── Feature ID utilities ──

/**
 * Extract the short feature ID from a full feature reference.
 * "ghcr.io/weftwiseink/devcontainer-features/wezterm-server:1" -> "wezterm-server"
 * "./features/my-feature" -> "my-feature"
 */
export function extractFeatureShortId(featureRef: string): string {
  // Strip version tag (":1", ":latest", ":1.2.3", etc.)
  const withoutVersion = featureRef.replace(/:[\w.-]+$/, "");
  // Take last path segment
  const segments = withoutVersion.split("/");
  return segments[segments.length - 1];
}

/**
 * Build a map from short feature ID to full feature reference.
 * Errors if two features share the same short ID.
 */
export function buildFeatureIdMap(
  features: Record<string, unknown>,
): Map<string, string> {
  const map = new Map<string, string>();
  for (const fullRef of Object.keys(features)) {
    const shortId = extractFeatureShortId(fullRef);
    if (map.has(shortId)) {
      throw new Error(
        `Feature ID collision: "${shortId}" matches both ` +
          `"${map.get(shortId)}" and "${fullRef}". ` +
          `Rename one using a local feature wrapper to disambiguate.`,
      );
    }
    map.set(shortId, fullRef);
  }
  return map;
}

// ── Auto-injection ──

/**
 * Auto-inject ${lace.port()} templates for feature options declared in
 * customizations.lace.ports metadata. Only injects for options the user
 * has NOT explicitly set.
 *
 * For top-level features: symmetric injection into the feature option value.
 * For prebuild features: asymmetric injection into appPort (host:defaultContainerPort).
 *
 * Modifies the config in-place before template resolution.
 * Returns the list of labels that were auto-injected (e.g., "wezterm-server/hostSshPort").
 */
export function autoInjectPortTemplates(
  config: Record<string, unknown>,
  metadataMap: Map<string, FeatureMetadata | null>,
): string[] {
  const features = (config.features ?? {}) as Record<
    string,
    Record<string, unknown>
  >;
  const prebuildFeatures = extractPrebuildFeaturesRaw(config);

  if (
    Object.keys(features).length === 0 &&
    Object.keys(prebuildFeatures).length === 0
  ) {
    return [];
  }

  const injected: string[] = [];

  // Process top-level features: symmetric injection into feature options (existing behavior)
  injectForBlock(features, metadataMap, injected);

  // Process prebuild features: asymmetric injection into appPort
  injectForPrebuildBlock(config, prebuildFeatures, metadataMap, injected);

  return injected;
}

/** Symmetric injection for top-level features. Mutates the block in-place. */
function injectForBlock(
  block: Record<string, Record<string, unknown>>,
  metadataMap: Map<string, FeatureMetadata | null>,
  injected: string[],
): void {
  for (const [fullRef, featureOptions] of Object.entries(block)) {
    const shortId = extractFeatureShortId(fullRef);
    const metadata = metadataMap.get(fullRef);
    if (!metadata) continue;

    const laceCustom = extractLaceCustomizations(metadata);
    if (!laceCustom?.ports) continue;

    for (const optionName of Object.keys(laceCustom.ports)) {
      // Skip if user has provided an explicit value for this option
      if (
        featureOptions &&
        typeof featureOptions === "object" &&
        optionName in featureOptions
      ) {
        continue;
      }

      // Ensure feature options object exists and is mutable
      if (!block[fullRef] || typeof block[fullRef] !== "object") {
        block[fullRef] = {};
      }
      (block[fullRef] as Record<string, unknown>)[optionName] =
        `\${lace.port(${shortId}/${optionName})}`;
      injected.push(`${shortId}/${optionName}`);
    }
  }
}

/** Asymmetric injection for prebuild features. Injects appPort entries, not feature options. */
function injectForPrebuildBlock(
  config: Record<string, unknown>,
  block: Record<string, Record<string, unknown>>,
  metadataMap: Map<string, FeatureMetadata | null>,
  injected: string[],
): void {
  for (const [fullRef, featureOptions] of Object.entries(block)) {
    const shortId = extractFeatureShortId(fullRef);
    const metadata = metadataMap.get(fullRef);
    if (!metadata) continue;

    const laceCustom = extractLaceCustomizations(metadata);
    if (!laceCustom?.ports) continue;

    for (const optionName of Object.keys(laceCustom.ports)) {
      // Skip if user has provided an explicit value for this option
      if (
        featureOptions &&
        typeof featureOptions === "object" &&
        optionName in featureOptions
      ) {
        continue;
      }

      // Get the feature's default port value from metadata
      const defaultPort = metadata.options?.[optionName]?.default;
      if (!defaultPort) continue; // Cannot generate asymmetric mapping without default

      // Inject asymmetric appPort entry: ${lace.port(...)}:DEFAULT_PORT
      const appPort = (config.appPort ?? []) as (string | number)[];
      const template = `\${lace.port(${shortId}/${optionName})}:${defaultPort}`;
      appPort.push(template);
      config.appPort = appPort;

      injected.push(`${shortId}/${optionName}`);
    }
  }
}

/** Result of auto-injecting mount templates. */
export interface MountAutoInjectionResult {
  /** Labels that were auto-injected into the mounts array. */
  injected: string[];
  /** Unified declarations map (project + feature + prebuild feature). */
  declarations: Record<string, LaceMountDeclaration>;
}

/**
 * Build a unified mount declarations map from project-level, feature-level,
 * and prebuild feature-level declarations.
 *
 * Project declarations come from `customizations.lace.mounts` in the devcontainer config.
 * Feature/prebuild feature declarations come from feature metadata's `customizations.lace.mounts`.
 *
 * Project declarations are prefixed with "project/".
 * Feature declarations are prefixed with "<shortId>/".
 * Mounts are runtime config (docker run flags), so prebuild features are treated identically
 * to regular features — no build/runtime asymmetry.
 */
export function buildMountDeclarationsMap(
  projectDeclarations: Record<string, LaceMountDeclaration>,
  metadataMap: Map<string, FeatureMetadata | null>,
): Record<string, LaceMountDeclaration> {
  const declarations: Record<string, LaceMountDeclaration> = {
    ...projectDeclarations,
  };

  for (const [fullRef, metadata] of metadataMap) {
    if (!metadata) continue;
    const shortId = extractFeatureShortId(fullRef);
    const laceCustom = extractLaceCustomizations(metadata);
    if (!laceCustom?.mounts) continue;

    for (const [mountName, value] of Object.entries(laceCustom.mounts)) {
      const parsed = parseMountDeclarationEntry(mountName, value);
      if (parsed) {
        declarations[`${shortId}/${mountName}`] = parsed;
      }
    }
  }

  return declarations;
}

// ── Mount declaration validation ──

/**
 * Validate that all mount declaration namespaces are recognized.
 * Valid namespaces are "project" (for project-level) or a known feature shortId.
 *
 * @param declarations The unified declarations map
 * @param featureShortIds Set of known feature short IDs (from features + prebuildFeatures)
 * @throws Error if any namespace is unknown
 */
export function validateMountNamespaces(
  declarations: Record<string, LaceMountDeclaration>,
  featureShortIds: Set<string>,
): void {
  const validNamespaces = new Set(["project", ...featureShortIds]);
  const unknownLabels: string[] = [];

  for (const label of Object.keys(declarations)) {
    const [namespace] = label.split("/");
    if (!validNamespaces.has(namespace)) {
      unknownLabels.push(label);
    }
  }

  if (unknownLabels.length > 0) {
    const available = Array.from(validNamespaces).sort().join(", ");
    throw new Error(
      `Unknown mount namespace(s): ${unknownLabels.map((l) => `"${l}"`).join(", ")}. ` +
        `Valid namespaces: ${available}`,
    );
  }
}

/**
 * Validate that no two declarations share the same container target path.
 *
 * @param declarations The unified declarations map
 * @throws Error if two labels declare the same target
 */
export function validateMountTargetConflicts(
  declarations: Record<string, LaceMountDeclaration>,
): void {
  const targetToLabel = new Map<string, string>();

  for (const [label, decl] of Object.entries(declarations)) {
    const existing = targetToLabel.get(decl.target);
    if (existing) {
      throw new Error(
        `Mount target conflict: '${decl.target}' declared by both '${existing}' and '${label}'`,
      );
    }
    targetToLabel.set(decl.target, label);
  }
}

/**
 * Emit guided configuration messages for mount paths.
 * Called after resolution to inform users about default paths and recommended overrides.
 *
 * When a default-path mount has a `recommendedSource`, checks whether that path
 * exists on the host to provide context-aware guidance:
 * - If it exists: suggests configuring it as an override (actionable)
 * - If it doesn't: shows as optional configuration (informational)
 */
export function emitMountGuidance(
  declarations: Record<string, LaceMountDeclaration>,
  assignments: Array<{ label: string; resolvedSource: string; isOverride: boolean }>,
): void {
  if (assignments.length === 0) return;

  const defaultAssignments = assignments.filter((a) => !a.isOverride);
  if (defaultAssignments.length === 0) return;

  const lines: string[] = ["Mount configuration:"];
  for (const assignment of assignments) {
    const decl = declarations[assignment.label];
    if (assignment.isOverride) {
      lines.push(`  ${assignment.label}: ${assignment.resolvedSource} (override)`);
    } else {
      lines.push(`  ${assignment.label}: using default path ${assignment.resolvedSource}`);
      if (decl?.recommendedSource) {
        const expandedRecommended = expandPath(decl.recommendedSource);
        if (existsSync(expandedRecommended)) {
          lines.push(`    → ${decl.recommendedSource} exists on host. Configure in settings.json to use it.`);
        } else {
          lines.push(`    → Optional: configure source to ${decl.recommendedSource} in settings.json`);
        }
      }
    }
  }

  // Only show settings hint if there are default-path mounts with recommendations
  // where the recommended source does NOT exist (actionable guidance)
  const unresolvedRecommendations = defaultAssignments.filter(
    (a) => {
      const decl = declarations[a.label];
      if (!decl?.recommendedSource) return false;
      return !existsSync(expandPath(decl.recommendedSource));
    },
  );
  if (unresolvedRecommendations.length > 0) {
    const exampleLabel = unresolvedRecommendations[0];
    const decl = declarations[exampleLabel.label];
    lines.push("");
    lines.push("To configure custom mount sources, add to ~/.config/lace/settings.json:");
    lines.push("{");
    lines.push('  "mounts": {');
    lines.push(`    "${exampleLabel.label}": { "source": "${decl!.recommendedSource}" }`);
    lines.push("  }");
    lines.push("}");
  }

  console.log(lines.join("\n"));
}

/**
 * Check if a mount label is already referenced in the mounts array
 * in any accessor form: ${lace.mount(label)}, ${lace.mount(label).source},
 * or ${lace.mount(label).target}.
 */
function mountLabelReferencedInMounts(
  mounts: string[],
  label: string,
): boolean {
  // Escape special regex chars in label (hyphens, underscores are safe but be safe)
  const escaped = label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const pattern = new RegExp(`\\$\\{lace\\.mount\\(${escaped}\\)(?:\\.(?:source|target))?\\}`);
  return mounts.some((m) => pattern.test(m));
}

/**
 * Auto-inject mount entries for all declarations not already referenced
 * in the config's mounts array. Handles project-level, feature-level, and
 * prebuild feature-level declarations.
 *
 * For each declaration label, scans the mounts array for any reference in
 * any accessor form (bare, .source, .target). If no reference found, appends
 * a bare ${lace.mount(ns/label)} entry.
 *
 * Mounts are runtime config (docker run flags), so prebuild features are
 * treated identically to regular features — no build/runtime asymmetry.
 *
 * Modifies the config in-place before template resolution.
 * Returns the injected labels and the unified declarations map.
 */
export function autoInjectMountTemplates(
  config: Record<string, unknown>,
  projectDeclarations: Record<string, LaceMountDeclaration>,
  metadataMap: Map<string, FeatureMetadata | null>,
): MountAutoInjectionResult {
  const declarations = buildMountDeclarationsMap(
    projectDeclarations,
    metadataMap,
  );

  const injected: string[] = [];

  for (const label of Object.keys(declarations)) {
    const mounts = (config.mounts ?? []) as string[];

    // Check if this label is already referenced in any accessor form
    if (mountLabelReferencedInMounts(mounts, label)) {
      continue;
    }

    // Append bare ${lace.mount(label)} — resolves to full spec during resolution
    mounts.push(`\${lace.mount(${label})}`);
    config.mounts = mounts;

    injected.push(label);
  }

  return { injected, declarations };
}

// ── Template resolution ──

/**
 * Resolve all ${lace.port()} and ${lace.mount()} expressions in the config.
 * Walks the entire config tree, replacing template expressions in string values.
 * Call autoInjectPortTemplates() and autoInjectMountTemplates() BEFORE this function.
 */
export async function resolveTemplates(
  config: Record<string, unknown>,
  portAllocator: PortAllocator,
  mountResolver?: MountPathResolver,
): Promise<TemplateResolutionResult> {
  const features = (config.features ?? {}) as Record<string, unknown>;
  const prebuildFeatures = extractPrebuildFeaturesRaw(config);
  const allFeatures = { ...features, ...prebuildFeatures };
  const featureIdMap = buildFeatureIdMap(allFeatures);
  const allocations: PortAllocation[] = [];
  const warnings: string[] = [];

  const resolvedConfig = (await walkAndResolve(
    structuredClone(config),
    featureIdMap,
    portAllocator,
    allocations,
    warnings,
    mountResolver,
  )) as Record<string, unknown>;

  const mountAssignments = mountResolver?.getAssignments() ?? [];
  return { resolvedConfig, allocations, warnings, mountAssignments };
}

/**
 * Recursively walk a value, resolving template expressions in strings.
 */
async function walkAndResolve(
  value: unknown,
  featureIdMap: Map<string, string>,
  portAllocator: PortAllocator,
  allocations: PortAllocation[],
  warnings: string[],
  mountResolver?: MountPathResolver,
): Promise<unknown> {
  if (typeof value === "string") {
    return resolveStringValue(value, featureIdMap, portAllocator, allocations, mountResolver);
  }
  if (Array.isArray(value)) {
    return Promise.all(
      value.map((item) =>
        walkAndResolve(item, featureIdMap, portAllocator, allocations, warnings, mountResolver),
      ),
    );
  }
  if (value !== null && typeof value === "object") {
    const obj = value as Record<string, unknown>;
    for (const key of Object.keys(obj)) {
      obj[key] = await walkAndResolve(
        obj[key],
        featureIdMap,
        portAllocator,
        allocations,
        warnings,
        mountResolver,
      );
    }
    return obj;
  }
  // Non-string primitives (number, boolean, null) pass through unchanged
  return value;
}

/**
 * Resolve template expressions in a single string value.
 * Returns number if the entire string is a single ${lace.port()} expression (type coercion).
 * Returns string if the expression is embedded in a larger string.
 *
 * v2 mount resolution order (more specific patterns first):
 * 1. ${lace.mount(label).target} -> declaration target path
 * 2. ${lace.mount(label).source} -> resolved host source path
 * 3. ${lace.mount(label)} -> complete mount spec string
 */
async function resolveStringValue(
  value: string,
  featureIdMap: Map<string, string>,
  portAllocator: PortAllocator,
  allocations: PortAllocation[],
  mountResolver?: MountPathResolver,
): Promise<string | number> {
  // Check for unknown ${lace.*} expressions (anything that isn't lace.port() or lace.mount())
  const unknownMatch = value.match(LACE_UNKNOWN_PATTERN);
  if (unknownMatch) {
    throw new Error(
      `Unknown template variable: \${lace.${unknownMatch[1]}}. ` +
        `Supported templates: \${lace.port(featureId/optionName)}, \${lace.mount(namespace/label)}, \${lace.mount(namespace/label).source}, \${lace.mount(namespace/label).target}.`,
    );
  }

  // Skip strings with no lace templates
  LACE_PORT_PATTERN.lastIndex = 0;
  LACE_MOUNT_TARGET_PATTERN.lastIndex = 0;
  LACE_MOUNT_SOURCE_PATTERN.lastIndex = 0;
  LACE_MOUNT_PATTERN.lastIndex = 0;
  const hasPortTemplates = LACE_PORT_PATTERN.test(value);
  const hasMountTargetTemplates = LACE_MOUNT_TARGET_PATTERN.test(value);
  const hasMountSourceTemplates = LACE_MOUNT_SOURCE_PATTERN.test(value);
  const hasMountBareTemplates = LACE_MOUNT_PATTERN.test(value);
  if (!hasPortTemplates && !hasMountTargetTemplates && !hasMountSourceTemplates && !hasMountBareTemplates) {
    return value;
  }
  // Reset regex state
  LACE_PORT_PATTERN.lastIndex = 0;
  LACE_MOUNT_TARGET_PATTERN.lastIndex = 0;
  LACE_MOUNT_SOURCE_PATTERN.lastIndex = 0;
  LACE_MOUNT_PATTERN.lastIndex = 0;

  // Type coercion: if the entire string is one ${lace.port()} expression, return integer
  const fullMatch = value.match(LACE_PORT_FULL_MATCH);
  if (fullMatch) {
    const label = fullMatch[1];
    const port = await resolvePortLabel(
      label,
      featureIdMap,
      portAllocator,
      allocations,
    );
    return port; // integer
  }

  // Embedded: replace all ${lace.port()} expressions, return string
  LACE_PORT_PATTERN.lastIndex = 0;
  const matches: Array<{ fullMatch: string; label: string }> = [];
  let match: RegExpExecArray | null;
  while ((match = LACE_PORT_PATTERN.exec(value)) !== null) {
    matches.push({ fullMatch: match[0], label: match[1] });
  }

  let result = value;
  for (const m of matches) {
    const port = await resolvePortLabel(
      m.label,
      featureIdMap,
      portAllocator,
      allocations,
    );
    result = result.replace(m.fullMatch, String(port));
  }

  // Mount resolution -- resolve more specific patterns first to avoid bare matching prefix
  if (mountResolver) {
    // 1. Mount .target resolution
    LACE_MOUNT_TARGET_PATTERN.lastIndex = 0;
    const targetMatches: Array<{ fullMatch: string; label: string }> = [];
    let targetMatch: RegExpExecArray | null;
    while ((targetMatch = LACE_MOUNT_TARGET_PATTERN.exec(result)) !== null) {
      targetMatches.push({ fullMatch: targetMatch[0], label: targetMatch[1] });
    }
    for (const m of targetMatches) {
      const targetPath = mountResolver.resolveTarget(m.label);
      result = result.replace(m.fullMatch, targetPath);
    }

    // 2. Mount .source resolution
    LACE_MOUNT_SOURCE_PATTERN.lastIndex = 0;
    const sourceMatches: Array<{ fullMatch: string; label: string }> = [];
    let sourceMatch: RegExpExecArray | null;
    while ((sourceMatch = LACE_MOUNT_SOURCE_PATTERN.exec(result)) !== null) {
      sourceMatches.push({ fullMatch: sourceMatch[0], label: sourceMatch[1] });
    }
    for (const m of sourceMatches) {
      const resolvedPath = mountResolver.resolveSource(m.label);
      result = result.replace(m.fullMatch, resolvedPath);
    }

    // 3. Mount bare resolution (full spec)
    LACE_MOUNT_PATTERN.lastIndex = 0;
    const bareMatches: Array<{ fullMatch: string; label: string }> = [];
    let bareMatch: RegExpExecArray | null;
    while ((bareMatch = LACE_MOUNT_PATTERN.exec(result)) !== null) {
      bareMatches.push({ fullMatch: bareMatch[0], label: bareMatch[1] });
    }
    for (const m of bareMatches) {
      const spec = mountResolver.resolveFullSpec(m.label);
      result = result.replace(m.fullMatch, spec);
    }
  }

  return result;
}

/**
 * Resolve a port label to a concrete port number.
 * Validates the featureId exists in the config.
 */
async function resolvePortLabel(
  label: string,
  featureIdMap: Map<string, string>,
  portAllocator: PortAllocator,
  allocations: PortAllocation[],
): Promise<number> {
  const parts = label.split("/");
  if (parts.length !== 2) {
    throw new Error(
      `Invalid port label "${label}". Expected format: featureId/optionName`,
    );
  }
  const [featureId] = parts;

  // Validate featureId exists in the config
  if (!featureIdMap.has(featureId)) {
    const available = Array.from(featureIdMap.keys()).join(", ");
    throw new Error(
      `Feature "${featureId}" not found in config. ` +
        `Available features: ${available}`,
    );
  }

  // Allocate or reuse port for this label
  const allocation = await portAllocator.allocate(label);
  // Track allocation if not already tracked
  if (!allocations.find((a) => a.label === label)) {
    allocations.push(allocation);
  }
  return allocation.port;
}

// ── Port entry generation ──

/**
 * Detect which allocated ports the user has already provided entries for,
 * and generate entries for the remaining ports.
 */
export function generatePortEntries(
  resolvedConfig: Record<string, unknown>,
  allocations: PortAllocation[],
  featurePortMetadata: Map<string, FeaturePortDeclaration> | null,
): AutoGeneratedPortEntries {
  const result: AutoGeneratedPortEntries = {
    appPort: [],
    forwardPorts: [],
    portsAttributes: {},
  };

  const userAppPort = (resolvedConfig.appPort ?? []) as (string | number)[];
  const userForwardPorts = (resolvedConfig.forwardPorts ?? []) as number[];
  const userPortsAttributes = (resolvedConfig.portsAttributes ?? {}) as Record<
    string,
    unknown
  >;

  for (const alloc of allocations) {
    const portStr = String(alloc.port);

    // Suppression: check if user already has an appPort entry for this port
    const hasUserAppPort = userAppPort.some((entry) =>
      String(entry).startsWith(`${alloc.port}:`),
    );
    if (!hasUserAppPort) {
      result.appPort.push(`${alloc.port}:${alloc.port}`);
    }

    // Suppression: check if user already has a forwardPorts entry
    const hasUserForwardPort = userForwardPorts.includes(alloc.port);
    if (!hasUserForwardPort) {
      result.forwardPorts.push(alloc.port);
    }

    // Suppression: check if user already has portsAttributes for this port
    if (!(portStr in userPortsAttributes)) {
      const featureMeta = featurePortMetadata?.get(alloc.label);
      const attrs: PortAttributes = {
        label: featureMeta?.label
          ? `${featureMeta.label} (lace)`
          : `${alloc.label} (lace)`,
        requireLocalPort: featureMeta?.requireLocalPort ?? true,
      };
      if (featureMeta?.onAutoForward) {
        attrs.onAutoForward = featureMeta.onAutoForward;
      }
      result.portsAttributes[portStr] = attrs;
    }
  }

  return result;
}

/**
 * Merge auto-generated port entries into the resolved config.
 */
export function mergePortEntries(
  config: Record<string, unknown>,
  generated: AutoGeneratedPortEntries,
): Record<string, unknown> {
  const merged = { ...config };

  // Merge appPort
  if (generated.appPort.length > 0) {
    const existing = (merged.appPort ?? []) as string[];
    merged.appPort = [...existing, ...generated.appPort];
  }

  // Merge forwardPorts
  if (generated.forwardPorts.length > 0) {
    const existing = (merged.forwardPorts ?? []) as number[];
    merged.forwardPorts = [...existing, ...generated.forwardPorts];
  }

  // Merge portsAttributes (user entries take precedence -- already excluded from generated)
  if (Object.keys(generated.portsAttributes).length > 0) {
    const existing = (merged.portsAttributes ?? {}) as Record<string, unknown>;
    merged.portsAttributes = { ...existing, ...generated.portsAttributes };
  }

  return merged;
}

/**
 * Build a map from port label to FeaturePortDeclaration from feature metadata.
 * Used to enrich auto-generated portsAttributes with feature-declared labels.
 */
export function buildFeaturePortMetadata(
  metadataMap: Map<string, FeatureMetadata | null>,
): Map<string, FeaturePortDeclaration> {
  const result = new Map<string, FeaturePortDeclaration>();

  for (const [fullRef, metadata] of metadataMap) {
    if (!metadata) continue;
    const shortId = extractFeatureShortId(fullRef);
    const laceCustom = extractLaceCustomizations(metadata);
    if (!laceCustom?.ports) continue;

    for (const [optionName, decl] of Object.entries(laceCustom.ports)) {
      const label = `${shortId}/${optionName}`;
      const entry: FeaturePortDeclaration = {
        label: decl.label,
        requireLocalPort: decl.requireLocalPort,
      };
      if (decl.onAutoForward) {
        entry.onAutoForward = decl.onAutoForward;
      }
      result.set(label, entry);
    }
  }

  return result;
}

/**
 * Check if any ${lace.port()} expressions exist in prebuildFeatures values
 * and return warnings for them.
 */
export function warnPrebuildPortTemplates(
  config: Record<string, unknown>,
): string[] {
  const warnings: string[] = [];
  const customizations = config.customizations as
    | Record<string, unknown>
    | undefined;
  if (!customizations) return warnings;

  const lace = customizations.lace as Record<string, unknown> | undefined;
  if (!lace?.prebuildFeatures) return warnings;

  const prebuildFeatures = lace.prebuildFeatures as Record<
    string,
    Record<string, unknown>
  >;

  for (const [featureRef, options] of Object.entries(prebuildFeatures)) {
    if (!options || typeof options !== "object") continue;
    for (const [optName, optValue] of Object.entries(options)) {
      if (typeof optValue === "string" && LACE_PORT_PATTERN.test(optValue)) {
        LACE_PORT_PATTERN.lastIndex = 0;
        warnings.push(
          `\${lace.port()} in prebuildFeatures option "${featureRef}".${optName} ` +
            `will not be resolved. Prebuild features use their default values.`,
        );
      }
    }
  }

  return warnings;
}

/**
 * Warn about port-declaring features in prebuildFeatures that have an explicit
 * static port value (opting out of auto-injection) but no appPort entry
 * referencing them. In that case, the feature listens on its static port inside
 * the container but has no host port mapping -- the container is invisible.
 *
 * This does NOT warn when:
 * - Auto-injection is active (no explicit value, so the label appears in `injected`)
 * - The user provides both a static value and an explicit appPort with ${lace.port()}
 */
export function warnPrebuildPortFeaturesStaticPort(
  config: Record<string, unknown>,
  metadataMap: Map<string, FeatureMetadata | null>,
  injected: string[],
): string[] {
  const warnings: string[] = [];
  const prebuildFeatures = extractPrebuildFeaturesRaw(config);
  if (Object.keys(prebuildFeatures).length === 0) return warnings;

  const appPort = (config.appPort ?? []) as (string | number)[];

  for (const [fullRef, featureOptions] of Object.entries(prebuildFeatures)) {
    const shortId = extractFeatureShortId(fullRef);
    const metadata = metadataMap.get(fullRef);
    if (!metadata) continue;

    const laceCustom = extractLaceCustomizations(metadata);
    if (!laceCustom?.ports) continue;

    for (const optionName of Object.keys(laceCustom.ports)) {
      const label = `${shortId}/${optionName}`;

      // Skip if auto-injection was active for this label (no explicit value was set)
      if (injected.includes(label)) continue;

      // The user has set an explicit value -- check if they also have an appPort entry
      const hasAppPortRef = appPort.some(
        (entry) =>
          typeof entry === "string" &&
          entry.includes(`\${lace.port(${label})}`),
      );
      if (hasAppPortRef) continue;

      const staticValue =
        featureOptions &&
        typeof featureOptions === "object" &&
        optionName in featureOptions
          ? featureOptions[optionName]
          : undefined;

      warnings.push(
        `Feature "${shortId}" in prebuildFeatures declares port "${optionName}" ` +
          `but has a static value (${JSON.stringify(staticValue ?? "default")}) and no appPort entry. ` +
          `The container will have no host port mapping for this port. ` +
          `Either remove the static value to enable auto-injection, or add an appPort entry.`,
      );
    }
  }

  return warnings;
}
