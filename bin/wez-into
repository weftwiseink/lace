#!/bin/bash
# wez-into -- Connect to a lace devcontainer via WezTerm.
#
# Usage:
#   wez-into                    Interactive picker (fzf or bash select)
#   wez-into <project>          Connect to named project
#   wez-into --start <project>  Start a stopped container, then connect
#   wez-into --start            Pick from stopped containers to start
#   wez-into --list             List running project names
#   wez-into --status           Show running projects with ports and paths
#   wez-into --dry-run <proj>   Print the wezterm connect command without executing
#   wez-into --help             Show this help
#
# Prerequisites: wezterm, docker, lace-discover on PATH or at known location

set -euo pipefail

SCRIPT_NAME="$(basename "$0")"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Dedicated known_hosts file for lace devcontainers.
# Must match M.KNOWN_HOSTS_FILE in the lace.wezterm plugin.
LACE_KNOWN_HOSTS="$HOME/.ssh/lace_known_hosts"

err() { echo "${SCRIPT_NAME}: error: $*" >&2; }
info() { echo "${SCRIPT_NAME}: $*" >&2; }

# --- Locate lace-discover ---
LACE_DISCOVER=""
if command -v lace-discover &>/dev/null; then
  LACE_DISCOVER="lace-discover"
else
  # Check known locations
  for candidate in \
    "$SCRIPT_DIR/lace-discover" \
    "$HOME/code/weft/lace/bin/lace-discover" \
    "/var/home/$(whoami)/code/weft/lace/bin/lace-discover"; do
    if [[ -x "$candidate" ]]; then
      LACE_DISCOVER="$candidate"
      break
    fi
  done
fi

if [[ -z "$LACE_DISCOVER" ]]; then
  err "lace-discover not found on PATH or at known locations"
  err "Install it or symlink to ~/.local/bin/"
  exit 1
fi

# --- Locate lace CLI ---
# Used by --start to run `lace up --workspace-folder <path>`.
# Check co-located path first (bin/wez-into -> packages/lace/bin/lace),
# then known locations, then PATH.
#
# Validates that the runtime interpreter (node) is available on PATH.
# The lace CLI is a node script (#!/usr/bin/env node), so finding the
# binary isn't enough — node must also be reachable.
locate_lace_cli() {
  local candidate
  for candidate in \
    "$SCRIPT_DIR/../packages/lace/bin/lace" \
    "$HOME/code/weft/lace/packages/lace/bin/lace" \
    "/var/home/$(whoami)/code/weft/lace/packages/lace/bin/lace"; do
    if [[ -x "$candidate" ]]; then
      echo "$candidate"
      return 0
    fi
  done
  # Fall back to PATH
  local path_lace
  path_lace="$(command -v lace 2>/dev/null || true)"
  if [[ -n "$path_lace" ]]; then
    echo "$path_lace"
    return 0
  fi
  return 1
}

# Verify that the lace CLI's runtime interpreter is available.
# The lace CLI uses #!/usr/bin/env node — if node isn't on PATH,
# execution fails with exit 127 and an opaque "No such file" error.
verify_lace_cli() {
  local lace_cli="$1"

  # Resolve symlinks to get the actual file and check its shebang
  local resolved
  resolved="$(readlink -f "$lace_cli" 2>/dev/null || echo "$lace_cli")"

  local shebang
  shebang="$(head -c 256 "$resolved" 2>/dev/null | head -1)"

  if [[ "$shebang" == "#!/usr/bin/env node"* ]] || [[ "$shebang" == "#!/usr/bin/node"* ]]; then
    if ! command -v node &>/dev/null; then
      err "lace CLI requires node, but node is not on PATH"
      err "found lace at: $lace_cli"
      err ""
      err "node is typically installed via linuxbrew:"
      err "  /home/linuxbrew/.linuxbrew/bin/node"
      err ""
      err "ensure your shell's PATH includes linuxbrew:"
      err "  export PATH=\"/home/linuxbrew/.linuxbrew/bin:\$PATH\""
      return 1
    fi
  fi
  return 0
}

# --- Discovery helper ---
discover() {
  "$LACE_DISCOVER" "$@"
}

# --- Stopped container discovery ---
# Query Docker for stopped devcontainers with the devcontainer.local_folder label.
# Output format: name\tworkspace_path per line
discover_stopped() {
  docker ps -a \
    --filter "label=devcontainer.local_folder" \
    --filter "status=exited" \
    --format '{{.Label "devcontainer.local_folder"}}' 2>/dev/null \
  | while IFS= read -r local_folder; do
    [[ -z "$local_folder" ]] && continue
    local name
    name=$(basename "$local_folder")
    printf '%s\t%s\n' "$name" "$local_folder"
  done
}

# --- Start a stopped container and connect ---
# Runs `lace up --workspace-folder <path>`, then re-discovers and connects.
start_and_connect() {
  local project="$1"
  local workspace_path="$2"

  local lace_cli
  lace_cli="$(locate_lace_cli)" || {
    err "lace CLI not found"
    err "Expected at: $SCRIPT_DIR/../packages/lace/bin/lace"
    err "Or install lace on PATH"
    exit 1
  }

  # Verify the runtime interpreter is available before attempting to run lace.
  # This catches the common case of node not being on PATH and gives a clear
  # diagnostic instead of a confusing "No such file or directory" + 20s of retries.
  verify_lace_cli "$lace_cli" || exit 1

  info "starting $project via lace up --workspace-folder $workspace_path ..."

  if [[ "$DRY_RUN" == "true" ]]; then
    echo "lace up --workspace-folder $workspace_path"
    echo "# then: wezterm connect lace:<port> --workspace $project"
    exit 0
  fi

  # Run lace up and capture output.
  # --skip-metadata-validation: some third-party features (e.g., nushell) lack
  # OCI metadata annotations. Since we are restarting an existing container (not
  # creating a new one), metadata validation is not critical.
  #
  # Note: lace up may exit non-zero even when the container starts successfully,
  # e.g. if postStartCommand fails (CWD mismatch, transient error). In that case
  # the container is running but lace up reports failure. We log the warning and
  # proceed to discovery -- if the container is actually running and discoverable,
  # we connect anyway.
  local up_output up_exit
  up_output=$("$lace_cli" up --workspace-folder "$workspace_path" --skip-metadata-validation 2>&1) || up_exit=$?
  up_exit=${up_exit:-0}

  if [[ $up_exit -eq 127 ]]; then
    # Exit 127 = command/interpreter not found. The container definitely did not start.
    err "lace CLI failed to execute (exit 127: command not found)"
    err "this usually means the node runtime is not on PATH"
    err ""
    err "lace CLI: $lace_cli"
    if [[ -n "$up_output" ]]; then
      err "output: $up_output"
    fi
    exit 1
  elif [[ $up_exit -eq 126 ]]; then
    # Exit 126 = permission denied or not executable
    err "lace CLI is not executable (exit 126: permission denied)"
    err "lace CLI: $lace_cli"
    exit 1
  elif [[ $up_exit -ne 0 ]]; then
    # Non-zero but not 126/127: lace ran but reported failure.
    # The container may still have started (e.g. postStartCommand failure).
    # Don't dump the stack trace yet -- wait to see if the container is discoverable.
    # If discovery succeeds, it was just a lifecycle hook failure (common, harmless).
    info "warning: lace up exited with code $up_exit (checking if container started anyway...)"
  else
    info "container started successfully"
  fi

  # Re-discover to get the current port (may have shifted after restart)
  local port=""
  local attempts=0
  local max_attempts=10

  while [[ $attempts -lt $max_attempts ]]; do
    while IFS=: read -r name p user path; do
      if [[ "$name" == "$project" ]]; then
        port="$p"
        break
      fi
    done < <(discover)

    if [[ -n "$port" ]]; then
      break
    fi

    attempts=$((attempts + 1))
    if [[ $attempts -lt $max_attempts ]]; then
      info "waiting for container to be discoverable (attempt $((attempts + 1))/$max_attempts)..."
      sleep 2
    fi
  done

  if [[ -z "$port" ]]; then
    if [[ $up_exit -ne 0 ]]; then
      err "lace up failed (exit $up_exit) and container is not discoverable"
      err "lace up output (last 15 lines):"
      echo "$up_output" | tail -15 >&2
    else
      err "container started but not discoverable after $max_attempts attempts"
      err "the container may need more time to start SSH"
    fi
    err "try: wez-into $project"
    exit 1
  fi

  # If lace up failed but the container IS discoverable, just note it briefly.
  # The stack trace is noise -- the container is running and we can connect.
  if [[ $up_exit -ne 0 ]]; then
    info "container is running despite lace up exit $up_exit (likely a lifecycle hook failure)"
  fi

  do_connect "$project" "$port"
}

# --- Argument parsing ---
PROJECT=""
ACTION=""
DRY_RUN=false
START=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --start)
      START=true
      shift
      ;;
    --list)
      ACTION="list"
      shift
      ;;
    --status)
      ACTION="status"
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    -h|--help)
      ACTION="help"
      shift
      ;;
    -*)
      err "unknown option: $1"
      echo "Usage: wez-into [PROJECT] [--start] [--list] [--status] [--dry-run] [--help]" >&2
      exit 1
      ;;
    *)
      PROJECT="$1"
      shift
      ;;
  esac
done

# --- Host key management ---
# Refresh the host key for a port in the lace known_hosts file.
# Removes any stale entry (from container recreation) and pre-populates
# the current key via ssh-keyscan. This prevents WezTerm's host key trust
# prompt entirely -- the key is already known when wezterm connect runs.
#
# WezTerm does NOT implement StrictHostKeyChecking, so there is no way to
# skip the prompt via ssh_option. Pre-populating known_hosts is the only
# mechanism available.
refresh_host_key() {
  local port="$1"

  # Ensure the file exists (ssh-keygen -R fails on missing file)
  mkdir -p "$(dirname "$LACE_KNOWN_HOSTS")"
  touch "$LACE_KNOWN_HOSTS"

  # Remove stale entry for this port (ignores errors if no entry exists).
  # ssh-keygen -R writes informational messages to stdout (not stderr),
  # so we must suppress both streams.
  ssh-keygen -f "$LACE_KNOWN_HOSTS" -R "[localhost]:$port" &>/dev/null || true

  # Pre-populate with the container's current host key.
  # ssh-keyscan is lightweight and fast for localhost connections.
  # Filter to key lines only (skip comments starting with #) to prevent
  # accumulating dead comment lines across repeated invocations.
  local keys
  keys=$(ssh-keyscan -p "$port" localhost 2>/dev/null | grep -v '^#') || true
  if [[ -n "$keys" ]]; then
    echo "$keys" >> "$LACE_KNOWN_HOSTS"
  else
    # ssh-keyscan failed (container not ready?). WezTerm will prompt once.
    info "warning: could not scan host key for port $port (container may still be starting)"
  fi
}

# --- Execute wezterm connect (or dry-run) ---
do_connect() {
  local project="$1"
  local port="$2"

  if [[ "$DRY_RUN" == "true" ]]; then
    echo "wezterm connect lace:$port --workspace $project"
    exit 0
  fi

  # Check wezterm prerequisite only when actually connecting
  if ! command -v wezterm &>/dev/null; then
    err "wezterm not found on PATH"
    exit 1
  fi

  # Pre-populate the host key so WezTerm doesn't prompt for trust
  refresh_host_key "$port"

  info "connecting to $project on port $port..."

  # Prefer `wezterm cli spawn` when a running WezTerm instance exists.
  # This returns immediately (non-blocking) and avoids inheriting
  # stdout/stderr noise (xkbcommon errors, lua logs, SSH messages).
  # WezTerm writes its own logs to $XDG_RUNTIME_DIR/wezterm/.
  if wezterm cli list &>/dev/null; then
    wezterm cli spawn --domain-name "lace:$port" --new-window --workspace "$project"
    return 0
  fi

  # No running instance -- fall back to exec wezterm connect.
  # Suppress xkbcommon errors from WezTerm's older bundled libxkbcommon
  # (it doesn't recognize newer keysyms like dead_hamza from Fedora's XKB data).
  export XKB_LOG_LEVEL=10  # critical only
  exec wezterm connect "lace:$port" --workspace "$project"
}

# --- Execute action ---
case "$ACTION" in
  list)
    discover | cut -d: -f1
    exit 0
    ;;
  status)
    projects_output=$(discover)
    if [[ -z "$projects_output" ]]; then
      info "no running devcontainers found"
      exit 0
    fi
    printf "%-20s %-8s %-10s %s\n" "PROJECT" "PORT" "USER" "PATH"
    printf "%-20s %-8s %-10s %s\n" "-------" "----" "----" "----"
    echo "$projects_output" | while IFS=: read -r name port user path; do
      printf "%-20s %-8s %-10s %s\n" "$name" "$port" "$user" "$path"
    done
    exit 0
    ;;
  help)
    cat <<'EOF'
wez-into -- Connect to a lace devcontainer via WezTerm

Usage:
  wez-into                    Interactive picker (fzf or bash select)
  wez-into <project>          Connect to named project
  wez-into --start <project>  Start a stopped container, then connect
  wez-into --start            Pick from stopped containers to start
  wez-into --list             List running project names
  wez-into --status           Show running projects with ports and paths
  wez-into --dry-run <proj>   Print the connect command without executing
  wez-into --help             Show this help

Projects are discovered via Docker (containers with devcontainer.local_folder
label and SSH ports in the 22425-22499 range). Discovery is performed by
lace-discover.

Connection uses WezTerm SSH domains pre-registered by the lace.wezterm plugin:
  wezterm connect lace:<port> --workspace <project>

The --start flag starts a stopped devcontainer before connecting. It uses
`lace up --workspace-folder <path>` for the full startup pipeline (config
generation, port allocation, lifecycle hooks). After startup, it re-discovers
the container and connects. If the project is already running, --start has
no effect (it just connects).

The --dry-run flag prints the command(s) that would be executed without
actually running them. When combined with --start, it prints both the
lace up command and the wezterm connect command.

Examples:
  wez-into lace                Connect to the lace devcontainer
  wez-into dotfiles            Connect to the dotfiles devcontainer
  wez-into                     Pick from running projects interactively
  wez-into --start lace        Start lace if stopped, then connect
  wez-into --start             Pick from stopped containers to start
  wez-into --start --dry-run lace  Show what --start would do
  wez-into --list              Show names of running projects
  wez-into --status            Show a table of running projects
  wez-into --dry-run lace      Print the connect command for lace
EOF
    exit 0
    ;;
esac

# --- Connect to a specific project ---
if [[ -n "$PROJECT" ]]; then
  # Step 1: Check if already running
  port=""

  while IFS=: read -r name p user path; do
    if [[ "$name" == "$PROJECT" ]]; then
      port="$p"
      break
    fi
  done < <(discover)

  if [[ -n "$port" ]]; then
    # Project is running -- connect directly (even if --start was given)
    if [[ "$START" == "true" ]]; then
      info "$PROJECT is already running"
    fi
    do_connect "$PROJECT" "$port"
    exit 0  # reached only if exec in do_connect fails (e.g. dry-run already exits)
  fi

  # Step 2: If --start, look for stopped containers
  if [[ "$START" == "true" ]]; then
    workspace_path=""

    while IFS=$'\t' read -r sname spath; do
      if [[ "$sname" == "$PROJECT" ]]; then
        workspace_path="$spath"
        break
      fi
    done < <(discover_stopped)

    if [[ -n "$workspace_path" ]]; then
      start_and_connect "$PROJECT" "$workspace_path"
      exit 0
    else
      # Not found in stopped containers either
      err "project '$PROJECT' not found in running or stopped containers"
      stopped_output=$(discover_stopped)
      if [[ -n "$stopped_output" ]]; then
        err ""
        err "stopped containers:"
        echo "$stopped_output" | while IFS=$'\t' read -r sname spath; do
          echo "  $sname  ($spath)" >&2
        done
      else
        err "no stopped devcontainers found"
      fi
      err ""
      err "to create a new container: lace up --workspace-folder <path>"
      exit 1
    fi
  fi

  # Not running and --start not given
  err "project '$PROJECT' not found in running containers"
  running=$(discover | cut -d: -f1)
  if [[ -n "$running" ]]; then
    err ""
    err "running projects:"
    echo "$running" | sed 's/^/  /' >&2
  else
    err "no running devcontainers found"
  fi

  # Hint about --start if there are stopped containers
  stopped_output=$(discover_stopped)
  if [[ -n "$stopped_output" ]]; then
    found_in_stopped=false
    while IFS=$'\t' read -r sname spath; do
      if [[ "$sname" == "$PROJECT" ]]; then
        found_in_stopped=true
        break
      fi
    done <<< "$stopped_output"
    if [[ "$found_in_stopped" == "true" ]]; then
      err ""
      err "hint: '$PROJECT' is stopped. Use --start to start it:"
      err "  wez-into --start $PROJECT"
    fi
  fi
  exit 1
fi

# --- Interactive picker ---

if [[ "$START" == "true" ]]; then
  # --start without a project name: show picker of stopped containers
  # Include running containers too (they just get connected directly)
  mapfile -t RUNNING < <(discover)
  mapfile -t STOPPED < <(discover_stopped)

  # Build combined list: running projects marked as [running], stopped as [stopped]
  PICKER_ITEMS=()
  PICKER_DATA=()  # parallel array: "running:name:port" or "stopped:name:path"

  for proj in "${RUNNING[@]}"; do
    IFS=: read -r name port user path <<< "$proj"
    PICKER_ITEMS+=("$name  [running]  :$port  $path")
    PICKER_DATA+=("running:$name:$port")
  done

  for line in "${STOPPED[@]}"; do
    IFS=$'\t' read -r name path <<< "$line"
    # Skip if already in running list
    already_running=false
    for proj in "${RUNNING[@]}"; do
      rname="${proj%%:*}"
      if [[ "$rname" == "$name" ]]; then
        already_running=true
        break
      fi
    done
    if [[ "$already_running" == "false" ]]; then
      PICKER_ITEMS+=("$name  [stopped]  $path")
      PICKER_DATA+=("stopped:$name:$path")
    fi
  done

  if [[ ${#PICKER_ITEMS[@]} -eq 0 ]]; then
    err "no running or stopped devcontainers found"
    err "to create a new container: lace up --workspace-folder <path>"
    exit 1
  fi

  if [[ ${#PICKER_ITEMS[@]} -eq 1 ]]; then
    IFS=: read -r kind name extra <<< "${PICKER_DATA[0]}"
    if [[ "$kind" == "running" ]]; then
      do_connect "$name" "$extra"
    else
      start_and_connect "$name" "$extra"
    fi
    exit 0
  fi

  # Multiple items -- show picker
  if command -v fzf &>/dev/null; then
    SELECTED=$(printf '%s\n' "${PICKER_ITEMS[@]}" | \
      fzf --prompt="wez-into --start> " --height=10 --reverse)
    [[ -z "$SELECTED" ]] && exit 0
    # Extract project name (first field)
    PICK_NAME=$(echo "$SELECTED" | awk '{print $1}')
  else
    PS3="wez-into --start> "
    mapfile -t DISPLAY_NAMES < <(printf '%s\n' "${PICKER_ITEMS[@]}")
    select PICK in "${DISPLAY_NAMES[@]}"; do
      [[ -n "$PICK" ]] && break
    done
    PICK_NAME=$(echo "$PICK" | awk '{print $1}')
  fi

  # Find matching entry in PICKER_DATA
  for i in "${!PICKER_ITEMS[@]}"; do
    item_name=$(echo "${PICKER_ITEMS[$i]}" | awk '{print $1}')
    if [[ "$item_name" == "$PICK_NAME" ]]; then
      IFS=: read -r kind name extra <<< "${PICKER_DATA[$i]}"
      if [[ "$kind" == "running" ]]; then
        do_connect "$name" "$extra"
      else
        start_and_connect "$name" "$extra"
      fi
      exit 0
    fi
  done

  err "internal error: selected project not found"
  exit 1
fi

# Normal interactive picker (no --start): running containers only
mapfile -t PROJECTS < <(discover)

if [[ ${#PROJECTS[@]} -eq 0 ]]; then
  err "no running devcontainers found"
  # Check if there are stopped containers and hint about --start
  stopped_output=$(discover_stopped)
  if [[ -n "$stopped_output" ]]; then
    err ""
    err "stopped containers available (use --start to start one):"
    echo "$stopped_output" | while IFS=$'\t' read -r sname spath; do
      echo "  $sname  ($spath)" >&2
    done
  else
    err "start a container with: lace up --workspace-folder <path>"
  fi
  exit 1
fi

if [[ ${#PROJECTS[@]} -eq 1 ]]; then
  IFS=: read -r name port user path <<< "${PROJECTS[0]}"
  info "one project found: $name"
  do_connect "$name" "$port"
  exit 0
fi

# Multiple projects -- show picker
if command -v fzf &>/dev/null; then
  SELECTED=$(printf '%s\n' "${PROJECTS[@]}" | \
    awk -F: '{printf "%-20s :%s  %s\n", $1, $2, $4}' | \
    fzf --prompt="wez-into> " --height=10 --reverse)
  [[ -z "$SELECTED" ]] && exit 0
  PROJECT=$(echo "$SELECTED" | awk '{print $1}')
else
  PS3="wez-into> "
  mapfile -t NAMES < <(printf '%s\n' "${PROJECTS[@]}" | cut -d: -f1)
  select PROJECT in "${NAMES[@]}"; do
    [[ -n "$PROJECT" ]] && break
  done
fi

# Find port for selected project
for proj in "${PROJECTS[@]}"; do
  if [[ "${proj%%:*}" == "$PROJECT" ]]; then
    IFS=: read -r _ port _ _ <<< "$proj"
    do_connect "$PROJECT" "$port"
    exit 0
  fi
done

err "internal error: selected project not found"
exit 1
