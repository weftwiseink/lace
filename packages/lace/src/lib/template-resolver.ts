// IMPLEMENTATION_VALIDATION
import type { PortAllocator, PortAllocation } from "./port-allocator";
import type { FeatureMetadata } from "./feature-metadata";
import { extractLaceCustomizations } from "./feature-metadata";
import type {
  AutoGeneratedPortEntries,
  FeaturePortDeclaration,
} from "./port-allocator";

// ── Types ──

/** Result of resolving all templates in a devcontainer.json. */
export interface TemplateResolutionResult {
  /** The config with all ${lace.port()} expressions replaced by concrete values. */
  resolvedConfig: Record<string, unknown>;
  /** All port allocations made during resolution (new and reused). */
  allocations: PortAllocation[];
  /** Warnings generated during resolution (e.g., metadata unavailable). */
  warnings: string[];
}

/** Parsed result of extracting a featureId from a feature reference. */
export interface ParsedFeatureRef {
  /** The full feature reference (e.g., "ghcr.io/weftwiseink/devcontainer-features/wezterm-server:1"). */
  fullRef: string;
  /** The short ID extracted from the last path segment, version stripped (e.g., "wezterm-server"). */
  shortId: string;
}

// ── Patterns ──

const LACE_PORT_PATTERN = /\$\{lace\.port\(([^)]+)\)\}/g;
const LACE_UNKNOWN_PATTERN = /\$\{lace\.(?!port\()([^}]+)\}/;
const LACE_PORT_FULL_MATCH = /^\$\{lace\.port\(([^)]+)\)\}$/;

// ── Feature ID utilities ──

/**
 * Extract the short feature ID from a full feature reference.
 * "ghcr.io/weftwiseink/devcontainer-features/wezterm-server:1" -> "wezterm-server"
 * "./features/my-feature" -> "my-feature"
 */
export function extractFeatureShortId(featureRef: string): string {
  // Strip version tag (":1", ":latest", ":1.2.3", etc.)
  const withoutVersion = featureRef.replace(/:[\w.-]+$/, "");
  // Take last path segment
  const segments = withoutVersion.split("/");
  return segments[segments.length - 1];
}

/**
 * Build a map from short feature ID to full feature reference.
 * Errors if two features share the same short ID.
 */
export function buildFeatureIdMap(
  features: Record<string, unknown>,
): Map<string, string> {
  const map = new Map<string, string>();
  for (const fullRef of Object.keys(features)) {
    const shortId = extractFeatureShortId(fullRef);
    if (map.has(shortId)) {
      throw new Error(
        `Feature ID collision: "${shortId}" matches both ` +
          `"${map.get(shortId)}" and "${fullRef}". ` +
          `Rename one using a local feature wrapper to disambiguate.`,
      );
    }
    map.set(shortId, fullRef);
  }
  return map;
}

// ── Auto-injection ──

/**
 * Auto-inject ${lace.port()} templates for feature options declared in
 * customizations.lace.ports metadata. Only injects for options the user
 * has NOT explicitly set.
 *
 * Modifies the config in-place before template resolution.
 * Returns the list of labels that were auto-injected (e.g., "wezterm-server/sshPort").
 */
export function autoInjectPortTemplates(
  config: Record<string, unknown>,
  metadataMap: Map<string, FeatureMetadata | null>,
): string[] {
  const features = (config.features ?? {}) as Record<
    string,
    Record<string, unknown>
  >;

  // Only build if there are features
  if (Object.keys(features).length === 0) return [];

  const injected: string[] = [];

  for (const [fullRef, featureOptions] of Object.entries(features)) {
    const shortId = extractFeatureShortId(fullRef);
    const metadata = metadataMap.get(fullRef);
    if (!metadata) continue;

    const laceCustom = extractLaceCustomizations(metadata);
    if (!laceCustom?.ports) continue;

    for (const optionName of Object.keys(laceCustom.ports)) {
      // Skip if user has provided an explicit value for this option
      if (
        featureOptions &&
        typeof featureOptions === "object" &&
        optionName in featureOptions
      ) {
        continue;
      }

      // Ensure feature options object exists and is mutable
      if (
        !features[fullRef] ||
        typeof features[fullRef] !== "object"
      ) {
        features[fullRef] = {};
      }
      (features[fullRef] as Record<string, unknown>)[optionName] =
        `\${lace.port(${shortId}/${optionName})}`;
      injected.push(`${shortId}/${optionName}`);
    }
  }

  return injected;
}

// ── Template resolution ──

/**
 * Resolve all ${lace.port()} expressions in the config.
 * Walks the entire config tree, replacing template expressions in string values.
 * Call autoInjectPortTemplates() BEFORE this function.
 */
export async function resolveTemplates(
  config: Record<string, unknown>,
  portAllocator: PortAllocator,
): Promise<TemplateResolutionResult> {
  const features = (config.features ?? {}) as Record<string, unknown>;
  const featureIdMap = buildFeatureIdMap(features);
  const allocations: PortAllocation[] = [];
  const warnings: string[] = [];

  const resolvedConfig = (await walkAndResolve(
    structuredClone(config),
    featureIdMap,
    portAllocator,
    allocations,
    warnings,
  )) as Record<string, unknown>;

  return { resolvedConfig, allocations, warnings };
}

/**
 * Recursively walk a value, resolving template expressions in strings.
 */
async function walkAndResolve(
  value: unknown,
  featureIdMap: Map<string, string>,
  portAllocator: PortAllocator,
  allocations: PortAllocation[],
  warnings: string[],
): Promise<unknown> {
  if (typeof value === "string") {
    return resolveStringValue(value, featureIdMap, portAllocator, allocations);
  }
  if (Array.isArray(value)) {
    return Promise.all(
      value.map((item) =>
        walkAndResolve(item, featureIdMap, portAllocator, allocations, warnings),
      ),
    );
  }
  if (value !== null && typeof value === "object") {
    const obj = value as Record<string, unknown>;
    for (const key of Object.keys(obj)) {
      obj[key] = await walkAndResolve(
        obj[key],
        featureIdMap,
        portAllocator,
        allocations,
        warnings,
      );
    }
    return obj;
  }
  // Non-string primitives (number, boolean, null) pass through unchanged
  return value;
}

/**
 * Resolve template expressions in a single string value.
 * Returns number if the entire string is a single ${lace.port()} expression (type coercion).
 * Returns string if the expression is embedded in a larger string.
 */
async function resolveStringValue(
  value: string,
  featureIdMap: Map<string, string>,
  portAllocator: PortAllocator,
  allocations: PortAllocation[],
): Promise<string | number> {
  // Check for unknown ${lace.*} expressions (anything that isn't lace.port(...))
  const unknownMatch = value.match(LACE_UNKNOWN_PATTERN);
  if (unknownMatch) {
    throw new Error(
      `Unknown template variable: \${lace.${unknownMatch[1]}}. ` +
        `The only supported template is \${lace.port(featureId/optionName)}.`,
    );
  }

  // Skip strings with no lace templates
  if (!LACE_PORT_PATTERN.test(value)) {
    return value;
  }
  LACE_PORT_PATTERN.lastIndex = 0; // Reset regex state

  // Type coercion: if the entire string is one ${lace.port()} expression, return integer
  const fullMatch = value.match(LACE_PORT_FULL_MATCH);
  if (fullMatch) {
    const label = fullMatch[1];
    const port = await resolvePortLabel(
      label,
      featureIdMap,
      portAllocator,
      allocations,
    );
    return port; // integer
  }

  // Embedded: replace all ${lace.port()} expressions, return string
  // We need to handle async resolution, so collect all matches first
  LACE_PORT_PATTERN.lastIndex = 0;
  const matches: Array<{ fullMatch: string; label: string }> = [];
  let match: RegExpExecArray | null;
  while ((match = LACE_PORT_PATTERN.exec(value)) !== null) {
    matches.push({ fullMatch: match[0], label: match[1] });
  }

  let result = value;
  for (const m of matches) {
    const port = await resolvePortLabel(
      m.label,
      featureIdMap,
      portAllocator,
      allocations,
    );
    result = result.replace(m.fullMatch, String(port));
  }
  return result;
}

/**
 * Resolve a port label to a concrete port number.
 * Validates the featureId exists in the config.
 */
async function resolvePortLabel(
  label: string,
  featureIdMap: Map<string, string>,
  portAllocator: PortAllocator,
  allocations: PortAllocation[],
): Promise<number> {
  const parts = label.split("/");
  if (parts.length !== 2) {
    throw new Error(
      `Invalid port label "${label}". Expected format: featureId/optionName`,
    );
  }
  const [featureId] = parts;

  // Validate featureId exists in the config
  if (!featureIdMap.has(featureId)) {
    const available = Array.from(featureIdMap.keys()).join(", ");
    throw new Error(
      `Feature "${featureId}" not found in config. ` +
        `Available features: ${available}`,
    );
  }

  // Allocate or reuse port for this label
  const allocation = await portAllocator.allocate(label);
  // Track allocation if not already tracked
  if (!allocations.find((a) => a.label === label)) {
    allocations.push(allocation);
  }
  return allocation.port;
}

// ── Port entry generation ──

/**
 * Detect which allocated ports the user has already provided entries for,
 * and generate entries for the remaining ports.
 */
export function generatePortEntries(
  resolvedConfig: Record<string, unknown>,
  allocations: PortAllocation[],
  featurePortMetadata: Map<string, FeaturePortDeclaration> | null,
): AutoGeneratedPortEntries {
  const result: AutoGeneratedPortEntries = {
    appPort: [],
    forwardPorts: [],
    portsAttributes: {},
  };

  const userAppPort = (resolvedConfig.appPort ?? []) as (string | number)[];
  const userForwardPorts = (resolvedConfig.forwardPorts ?? []) as number[];
  const userPortsAttributes = (resolvedConfig.portsAttributes ?? {}) as Record<
    string,
    unknown
  >;

  for (const alloc of allocations) {
    const portStr = String(alloc.port);

    // Suppression: check if user already has an appPort entry for this port
    const hasUserAppPort = userAppPort.some((entry) =>
      String(entry).startsWith(`${alloc.port}:`),
    );
    if (!hasUserAppPort) {
      result.appPort.push(`${alloc.port}:${alloc.port}`);
    }

    // Suppression: check if user already has a forwardPorts entry
    const hasUserForwardPort = userForwardPorts.includes(alloc.port);
    if (!hasUserForwardPort) {
      result.forwardPorts.push(alloc.port);
    }

    // Suppression: check if user already has portsAttributes for this port
    if (!(portStr in userPortsAttributes)) {
      const featureMeta = featurePortMetadata?.get(alloc.label);
      result.portsAttributes[portStr] = {
        label: featureMeta?.label
          ? `${featureMeta.label} (lace)`
          : `${alloc.label} (lace)`,
        requireLocalPort: featureMeta?.requireLocalPort ?? true,
      };
    }
  }

  return result;
}

/**
 * Merge auto-generated port entries into the resolved config.
 */
export function mergePortEntries(
  config: Record<string, unknown>,
  generated: AutoGeneratedPortEntries,
): Record<string, unknown> {
  const merged = { ...config };

  // Merge appPort
  if (generated.appPort.length > 0) {
    const existing = (merged.appPort ?? []) as string[];
    merged.appPort = [...existing, ...generated.appPort];
  }

  // Merge forwardPorts
  if (generated.forwardPorts.length > 0) {
    const existing = (merged.forwardPorts ?? []) as number[];
    merged.forwardPorts = [...existing, ...generated.forwardPorts];
  }

  // Merge portsAttributes (user entries take precedence -- already excluded from generated)
  if (Object.keys(generated.portsAttributes).length > 0) {
    const existing = (merged.portsAttributes ?? {}) as Record<string, unknown>;
    merged.portsAttributes = { ...existing, ...generated.portsAttributes };
  }

  return merged;
}

/**
 * Build a map from port label to FeaturePortDeclaration from feature metadata.
 * Used to enrich auto-generated portsAttributes with feature-declared labels.
 */
export function buildFeaturePortMetadata(
  metadataMap: Map<string, FeatureMetadata | null>,
): Map<string, FeaturePortDeclaration> {
  const result = new Map<string, FeaturePortDeclaration>();

  for (const [fullRef, metadata] of metadataMap) {
    if (!metadata) continue;
    const shortId = extractFeatureShortId(fullRef);
    const laceCustom = extractLaceCustomizations(metadata);
    if (!laceCustom?.ports) continue;

    for (const [optionName, decl] of Object.entries(laceCustom.ports)) {
      const label = `${shortId}/${optionName}`;
      result.set(label, {
        label: decl.label,
        requireLocalPort: decl.requireLocalPort,
      });
    }
  }

  return result;
}

/**
 * Check if any ${lace.port()} expressions exist in prebuildFeatures values
 * and return warnings for them.
 */
export function warnPrebuildPortTemplates(
  config: Record<string, unknown>,
): string[] {
  const warnings: string[] = [];
  const customizations = config.customizations as
    | Record<string, unknown>
    | undefined;
  if (!customizations) return warnings;

  const lace = customizations.lace as Record<string, unknown> | undefined;
  if (!lace?.prebuildFeatures) return warnings;

  const prebuildFeatures = lace.prebuildFeatures as Record<
    string,
    Record<string, unknown>
  >;

  for (const [featureRef, options] of Object.entries(prebuildFeatures)) {
    if (!options || typeof options !== "object") continue;
    for (const [optName, optValue] of Object.entries(options)) {
      if (typeof optValue === "string" && LACE_PORT_PATTERN.test(optValue)) {
        LACE_PORT_PATTERN.lastIndex = 0;
        warnings.push(
          `\${lace.port()} in prebuildFeatures option "${featureRef}".${optName} ` +
            `will not be resolved. Prebuild features use their default values.`,
        );
      }
    }
  }

  return warnings;
}
