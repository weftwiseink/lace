// IMPLEMENTATION_VALIDATION
import { existsSync, readFileSync, writeFileSync, mkdirSync } from "node:fs";
import { join } from "node:path";
import * as net from "node:net";

// Port range for lace devcontainer port allocations
// w=22, e=4, z=25 spells "wez" in alphabet positions
export const LACE_PORT_MIN = 22425;
export const LACE_PORT_MAX = 22499;

/**
 * Check if a port is available (not in use) on localhost.
 * Uses TCP connect with a short timeout.
 *
 * @param port Port number to check
 * @param timeout Connection timeout in milliseconds (default 100ms)
 * @returns Promise that resolves to true if port is available, false if in use
 */
export function isPortAvailable(
  port: number,
  timeout = 100,
): Promise<boolean> {
  return new Promise((resolve) => {
    const socket = new net.Socket();
    socket.setTimeout(timeout);

    socket.once("connect", () => {
      socket.destroy();
      resolve(false); // Port is in use
    });

    socket.once("timeout", () => {
      socket.destroy();
      resolve(true); // Port is available (connection timed out)
    });

    socket.once("error", () => {
      socket.destroy();
      resolve(true); // Port is available (connection refused or other error)
    });

    socket.connect(port, "localhost");
  });
}

// ── Types ──

/** A single port allocation tracked by lace. */
export interface PortAllocation {
  /** The label that identifies this allocation (e.g., "wezterm-server/sshPort"). */
  label: string;
  /** The allocated port number, used symmetrically on host and container. */
  port: number;
  /** ISO 8601 timestamp of when this allocation was first created. */
  assignedAt: string;
}

/** Persisted state in .lace/port-assignments.json. */
export interface PortAssignmentsFile {
  /** Map from label to allocation details. */
  assignments: Record<string, PortAllocation>;
}

/** Attributes for a single port in portsAttributes. */
export interface PortAttributes {
  /** Human-readable label for the port (e.g., "wezterm ssh (lace)"). */
  label: string;
  /** Whether to require the exact local port number (fail if unavailable). */
  requireLocalPort: boolean;
}

/** Auto-generated port entries to merge into the final config. */
export interface AutoGeneratedPortEntries {
  /** Docker -p bindings: ["22430:22430", ...] */
  appPort: string[];
  /** VS Code forwarding: [22430, ...] */
  forwardPorts: number[];
  /** Port labels and behavior: { "22430": { label, requireLocalPort } } */
  portsAttributes: Record<string, PortAttributes>;
}

/** Port metadata declared by a feature in its devcontainer-feature.json. */
export interface FeaturePortDeclaration {
  /** Display label for the port. Lace appends " (lace)" suffix. */
  label?: string;
  /** Whether to require the exact local port. Default: true. */
  requireLocalPort?: boolean;
}

// ── PortAllocator ──

export class PortAllocator {
  private assignments: Map<string, PortAllocation> = new Map();
  private persistPath: string;

  constructor(private workspaceFolder: string) {
    this.persistPath = join(
      workspaceFolder,
      ".lace",
      "port-assignments.json",
    );
    this.load();
  }

  /** Load persisted assignments from disk. */
  private load(): void {
    if (!existsSync(this.persistPath)) return;
    try {
      const raw = JSON.parse(
        readFileSync(this.persistPath, "utf-8"),
      ) as PortAssignmentsFile;
      for (const [label, alloc] of Object.entries(raw.assignments ?? {})) {
        this.assignments.set(label, alloc);
      }
    } catch {
      // Corrupt file -- start fresh, will be overwritten on save
    }
  }

  /** Persist current assignments to disk. */
  save(): void {
    const dir = join(this.workspaceFolder, ".lace");
    mkdirSync(dir, { recursive: true });
    const file: PortAssignmentsFile = {
      assignments: Object.fromEntries(this.assignments),
    };
    writeFileSync(
      this.persistPath,
      JSON.stringify(file, null, 2) + "\n",
      "utf-8",
    );
  }

  /** Allocate a port for a label. Reuses existing assignment if port is available. */
  async allocate(label: string): Promise<PortAllocation> {
    const existing = this.assignments.get(label);
    if (existing && (await isPortAvailable(existing.port))) {
      return existing;
    }

    if (existing) {
      console.warn(
        `Port ${existing.port} for "${label}" is in use, reassigning...`,
      );
    }

    const port = await this.findAvailablePort();
    if (port === null) {
      const labels = Array.from(this.assignments.entries())
        .map(([l, a]) => `  ${l}: ${a.port}`)
        .join("\n");
      throw new Error(
        `All ports in range ${LACE_PORT_MIN}-${LACE_PORT_MAX} are in use.\n` +
          `Active assignments:\n${labels}`,
      );
    }

    const allocation: PortAllocation = {
      label,
      port,
      assignedAt: new Date().toISOString(),
    };
    this.assignments.set(label, allocation);
    return allocation;
  }

  /** Find first available port in range, skipping already-assigned ports. */
  private async findAvailablePort(): Promise<number | null> {
    const usedPorts = new Set(
      Array.from(this.assignments.values()).map((a) => a.port),
    );
    for (let port = LACE_PORT_MIN; port <= LACE_PORT_MAX; port++) {
      if (usedPorts.has(port)) continue;
      if (await isPortAvailable(port)) return port;
    }
    return null;
  }

  /** Get all current allocations. */
  getAllocations(): PortAllocation[] {
    return Array.from(this.assignments.values());
  }
}
