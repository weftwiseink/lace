#!/bin/bash
# Open a WezTerm workspace connected to the lace devcontainer.
#
# Usage:
#   devcontainer up --workspace-folder . | ./bin/open-lace-workspace   (piped mode)
#   ./bin/open-lace-workspace                                          (standalone mode)
#   ./bin/open-lace-workspace --rebuild                                (rebuild container)
#
# Piped mode: reads devcontainer up JSON from stdin, validates success,
# waits for SSH readiness, and opens a WezTerm window connected to the
# lace SSH domain.
#
# Standalone mode: runs devcontainer up internally, then proceeds as above.
#
# Options:
#   --rebuild, --no-cache   Remove existing container and rebuild image (standalone mode only)
#
# Prerequisites:
#   - wezterm installed on the host
#   - SSH key pair at ~/.ssh/lace_devcontainer
#     Generate with: ssh-keygen -t ed25519 -f ~/.ssh/lace_devcontainer -N ""
#   - devcontainer CLI installed (standalone mode only)
#     Install with: npm install -g @devcontainers/cli
#
# Exit codes:
#   0 - Success (WezTerm window opened)
#   1 - Prerequisite failure (missing tool or SSH key)
#   2 - devcontainer up failure (non-success outcome or JSON parse error)
#   3 - SSH connectivity timeout (sshd not reachable after max retries)
#   4 - wezterm connect failure (mux server not running or connection error)
#
# Design rationale: cdocs/proposals/2026-02-01-devcontainer-auto-attach-wezterm-workspace.md

set -euo pipefail

SCRIPT_NAME="$(basename "$0")"

# --- Resolve repo root using SCRIPT_DIR pattern from bin/nvim ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"

# --- Configuration constants ---
SSH_KEY="$HOME/.ssh/lace_devcontainer"
SSH_PORT=2222
SSH_USER="node"
SSH_HOST="localhost"
MAX_SSH_ATTEMPTS=15
SSH_RETRY_INTERVAL=1

# --- Argument parsing ---
DC_EXTRA_ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --rebuild|--no-cache)
      DC_EXTRA_ARGS+=("--remove-existing-container" "--build-no-cache")
      shift
      ;;
    -h|--help)
      head -28 "${BASH_SOURCE[0]}" | tail -n +2 | sed 's/^# \?//'
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      echo "Usage: $0 [--rebuild] [--help]" >&2
      exit 1
      ;;
  esac
done

# --- Helper: print error messages prefixed with script name ---
err() {
  echo "${SCRIPT_NAME}: error: $*" >&2
}

info() {
  echo "${SCRIPT_NAME}: $*" >&2
}

# --- Phase A: Prerequisite checks ---

if ! command -v wezterm &>/dev/null; then
  err "wezterm not found on PATH"
  err "Install from: https://wezfurlong.org/wezterm/installation.html"
  exit 1
fi

if [[ ! -f "$SSH_KEY" ]]; then
  err "SSH key not found at $SSH_KEY"
  err "Generate with: ssh-keygen -t ed25519 -f $SSH_KEY -N \"\""
  exit 1
fi

# --- Phase B: Obtain devcontainer up JSON ---

if [ ! -t 0 ]; then
  # --- Piped mode ---
  if [[ ${#DC_EXTRA_ARGS[@]} -gt 0 ]]; then
    info "warning: --rebuild ignored in piped mode (caller controls devcontainer up flags)"
  fi
  info "reading devcontainer up output from stdin..."
  RAW_INPUT="$(cat)"

  # Extract the JSON line: find the line containing "outcome"
  # Use || true to prevent set -e from aborting on no match
  JSON_LINE="$(echo "$RAW_INPUT" | grep '"outcome"' | head -1 || true)"

  if [[ -z "$JSON_LINE" ]]; then
    err "failed to find JSON output in stdin (no line containing '\"outcome\"')"
    err "raw input (first 5 lines):"
    echo "$RAW_INPUT" | head -5 >&2
    exit 2
  fi
else
  # --- Standalone mode ---
  if ! command -v devcontainer &>/dev/null; then
    err "devcontainer CLI not found on PATH (required for standalone mode)"
    err "Install with: npm install -g @devcontainers/cli"
    err "Or use piped mode: devcontainer up --workspace-folder . | $0"
    exit 1
  fi

  # Check if the container is already running before invoking devcontainer up
  CONTAINER_RUNNING=""
  if command -v docker &>/dev/null; then
    CONTAINER_RUNNING="$(docker ps -q --filter "label=devcontainer.local_folder=$REPO_ROOT" 2>/dev/null || true)"
  fi

  SKIP_DC_UP=false
  if [[ -n "$CONTAINER_RUNNING" ]] && [[ ${#DC_EXTRA_ARGS[@]} -eq 0 ]]; then
    # Container is running and no explicit --rebuild requested
    info "container is already running ($(echo "$CONTAINER_RUNNING" | head -1 | cut -c1-12))"

    if [ -t 1 ]; then
      # Interactive TTY -- prompt the user
      echo "" >&2
      echo "  [r] Reconnect (open WezTerm window)" >&2
      echo "  [b] Rebuild (stop, rebuild, reconnect)" >&2
      echo "  [q] Quit" >&2
      echo "" >&2
      read -r -n 1 -p "Choose [r/b/q]: " CHOICE </dev/tty >&2
      echo "" >&2

      case "$CHOICE" in
        r|R|"")
          info "reconnecting to existing container..."
          SKIP_DC_UP=true
          ;;
        b|B)
          info "rebuilding container..."
          DC_EXTRA_ARGS+=("--rebuild")
          ;;
        q|Q)
          info "quitting"
          exit 0
          ;;
        *)
          err "invalid choice: $CHOICE"
          exit 1
          ;;
      esac
    else
      # Non-interactive -- default to reconnect
      info "non-interactive mode: reconnecting to existing container"
      SKIP_DC_UP=true
    fi
  fi

  if [[ "$SKIP_DC_UP" == "false" ]]; then
    info "running devcontainer up --workspace-folder $REPO_ROOT ${DC_EXTRA_ARGS[*]+"${DC_EXTRA_ARGS[*]}"} ..."
    DC_EXIT=0
    RAW_OUTPUT="$(devcontainer up --workspace-folder "$REPO_ROOT" ${DC_EXTRA_ARGS[@]+"${DC_EXTRA_ARGS[@]}"} 2>&1)" || DC_EXIT=$?

    # Extract JSON line from mixed output
    JSON_LINE="$(echo "$RAW_OUTPUT" | grep '"outcome"' | head -1 || true)"

    if [[ -z "$JSON_LINE" ]]; then
      err "devcontainer up did not produce JSON output (exit code: $DC_EXIT)"
      err "raw output (last 10 lines):"
      echo "$RAW_OUTPUT" | tail -10 >&2
      exit 2
    fi
  fi
fi

# --- Phase C: Parse JSON and validate outcome ---
# Skipped when reconnecting to an already-running container (no devcontainer up output)

if [[ -n "${JSON_LINE:-}" ]]; then
  if command -v jq &>/dev/null; then
    OUTCOME="$(echo "$JSON_LINE" | jq -r '.outcome')"
  else
    # Fallback: extract outcome value using grep + sed
    OUTCOME="$(echo "$JSON_LINE" | grep -o '"outcome"\s*:\s*"[^"]*"' | sed 's/.*"\([^"]*\)"$/\1/' || true)"
  fi

  if [[ "$OUTCOME" != "success" ]]; then
    # Check if a containerId is present -- the container may be running despite
    # a lifecycle hook failure (e.g., postStartCommand fails but container is up).
    if command -v jq &>/dev/null; then
      CONTAINER_ID="$(echo "$JSON_LINE" | jq -r '.containerId // empty')"
    else
      CONTAINER_ID="$(echo "$JSON_LINE" | grep -o '"containerId"\s*:\s*"[^"]*"' | sed 's/.*"\([^"]*\)"$/\1/' || true)"
    fi

    if [[ -n "${CONTAINER_ID:-}" ]]; then
      # Container is running but a hook failed -- warn and proceed
      info "warning: devcontainer up reported outcome '$OUTCOME' but container is running"
      if command -v jq &>/dev/null; then
        MSG="$(echo "$JSON_LINE" | jq -r '.message // .description // empty')"
      else
        MSG="$(echo "$JSON_LINE" | grep -o '"message"\s*:\s*"[^"]*"' | sed 's/.*"\([^"]*\)"$/\1/' || true)"
      fi
      [[ -n "${MSG:-}" ]] && info "warning: $MSG"
      info "proceeding with SSH readiness check..."
    else
      # No containerId -- genuine failure, container did not start
      err "devcontainer up reported outcome: $OUTCOME"
      if command -v jq &>/dev/null; then
        MSG="$(echo "$JSON_LINE" | jq -r '.message // .description // empty')"
      else
        MSG="$(echo "$JSON_LINE" | grep -o '"message"\s*:\s*"[^"]*"' | sed 's/.*"\([^"]*\)"$/\1/' || true)"
      fi
      [[ -n "${MSG:-}" ]] && err "message: $MSG"
      exit 2
    fi
  else
    info "devcontainer up succeeded"
  fi
fi

# --- Phase D: SSH readiness polling ---

info "waiting for SSH readiness on port $SSH_PORT..."
ATTEMPT=0
while [[ $ATTEMPT -lt $MAX_SSH_ATTEMPTS ]]; do
  ATTEMPT=$((ATTEMPT + 1))
  if ssh -p "$SSH_PORT" \
       -i "$SSH_KEY" \
       -o ConnectTimeout=1 \
       -o StrictHostKeyChecking=no \
       -o UserKnownHostsFile=/dev/null \
       -o LogLevel=ERROR \
       "${SSH_USER}@${SSH_HOST}" true 2>/dev/null; then
    info "SSH ready (attempt $ATTEMPT/$MAX_SSH_ATTEMPTS)"
    break
  fi

  if [[ $ATTEMPT -eq $MAX_SSH_ATTEMPTS ]]; then
    err "SSH connectivity timeout after $MAX_SSH_ATTEMPTS attempts"
    err "troubleshooting:"
    err "  - verify container is running: docker ps | grep devcontainer"
    err "  - verify sshd is running: devcontainer exec --workspace-folder $REPO_ROOT -- pgrep -a sshd"
    err "  - verify port binding: ss -tlnp | grep $SSH_PORT"
    err "  - test SSH manually: ssh -p $SSH_PORT -i $SSH_KEY -v ${SSH_USER}@${SSH_HOST} true"
    exit 3
  fi

  sleep "$SSH_RETRY_INTERVAL"
done

# --- Phase E: Open WezTerm window ---
#
# wezterm connect blocks for the lifetime of the GUI window it opens.
# We background it and briefly check that the process is still alive,
# which catches immediate connection failures (bad domain, SSH error).

# Verify container-side mux server is running (catches silent postStartCommand failures)
if command -v docker &>/dev/null; then
  if ! docker exec "$(docker ps -q --filter "label=devcontainer.local_folder=$REPO_ROOT" | head -1)" pgrep -f wezterm-mux-server >/dev/null 2>&1; then
    info "wezterm-mux-server not detected in container; starting..."
    if ! docker exec "$(docker ps -q --filter "label=devcontainer.local_folder=$REPO_ROOT" | head -1)" wezterm-mux-server --daemonize 2>/dev/null; then
      err "failed to start wezterm-mux-server in container"
      err "try manually: docker exec <container> wezterm-mux-server --daemonize"
      exit 4
    fi
    sleep 1
  fi
fi

# Check for existing WezTerm connection to the lace domain.
# wezterm cli list requires a running host mux (unix_domains config).
# Panes connected to the container have cwd under file:///workspace/.
EXISTING_PANE=""
if PANE_LIST="$(timeout 2 wezterm cli list --format json 2>/dev/null)"; then
  if command -v jq &>/dev/null; then
    EXISTING_PANE="$(echo "$PANE_LIST" | jq -r '[.[] | select(.cwd | startswith("file:///workspace/"))][0] // empty | .pane_id // empty')"
  else
    # Fallback: grep for workspace cwd pattern
    if echo "$PANE_LIST" | grep -q '"cwd"\s*:\s*"file:///workspace/' 2>/dev/null; then
      EXISTING_PANE="found"
    fi
  fi
fi

if [[ -n "$EXISTING_PANE" ]]; then
  info "existing WezTerm connection to lace domain detected"
  if [ -t 1 ]; then
    echo "" >&2
    echo "  [o] Open new window anyway" >&2
    echo "  [q] Quit (use existing window)" >&2
    echo "" >&2
    read -r -n 1 -p "Choose [o/q]: " CHOICE </dev/tty >&2
    echo "" >&2

    case "$CHOICE" in
      o|O)
        info "opening additional WezTerm window..."
        ;;
      q|Q|"")
        info "using existing connection"
        exit 0
        ;;
      *)
        err "invalid choice: $CHOICE"
        exit 1
        ;;
    esac
  else
    info "existing connection found; skipping new window in non-interactive mode"
    exit 0
  fi
fi

# Ensure WezTerm uses the lace config (which defines the lace SSH domain).
# Without this, wezterm connect won't find the domain unless the user has
# symlinked config/wezterm/wezterm.lua to ~/.config/wezterm/wezterm.lua.
export WEZTERM_CONFIG_FILE="${WEZTERM_CONFIG_FILE:-$REPO_ROOT/config/wezterm/wezterm.lua}"

# Connect to the lace domain.
# The container-side wezterm config sets default_cwd = "/workspace/lace".
# Redirect wezterm output to a log file to avoid cluttering the terminal with
# xkbcommon/wayland warnings, while still capturing errors for debugging.
WEZTERM_LOG_FILE="/tmp/open-lace-workspace-wezterm.log"
info "connecting WezTerm to lace domain..."
info "wezterm output logged to: $WEZTERM_LOG_FILE"
wezterm connect lace >"$WEZTERM_LOG_FILE" 2>&1 &
WEZ_PID=$!

# Give wezterm a moment to fail on immediate errors (bad config, SSH rejection)
# Show any errors that appear in the log during startup
sleep 2

if ! kill -0 "$WEZ_PID" 2>/dev/null; then
  # Process already exited -- retrieve its exit code
  WEZ_EXIT=0
  wait "$WEZ_PID" 2>/dev/null || WEZ_EXIT=$?
  err "wezterm connect lace failed (exit code: $WEZ_EXIT)"
  # Show log contents to help diagnose the failure
  if [[ -s "$WEZTERM_LOG_FILE" ]]; then
    err "wezterm log output:"
    cat "$WEZTERM_LOG_FILE" >&2
  fi
  err "troubleshooting:"
  err "  - verify mux server: devcontainer exec --workspace-folder $REPO_ROOT -- pgrep -a wezterm"
  err "  - restart mux server: devcontainer exec --workspace-folder $REPO_ROOT -- wezterm-mux-server --daemonize"
  err "  - debug connection: WEZTERM_LOG=debug wezterm connect lace"
  exit 4
fi

# Detach the GUI process so it survives the parent shell exiting
disown "$WEZ_PID"
info "WezTerm window opened (pid $WEZ_PID)"
